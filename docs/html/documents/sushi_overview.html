
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Sushi: The DAW Inside Elk &#8212; Elk DevKit  documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Sushi Configuration" href="sushi_configuration_format.html" />
    <link rel="prev" title="Run Elk on Boards" href="run_elk_on_boards.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="sushi_configuration_format.html" title="Sushi Configuration"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="run_elk_on_boards.html" title="Run Elk on Boards"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Elk DevKit  documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="sushi-the-daw-inside-elk">
<h1>Sushi: The DAW Inside Elk<a class="headerlink" href="#sushi-the-daw-inside-elk" title="Permalink to this headline">¶</a></h1>
<p>The Elk Music Operating System consists of many different parts. In this post I will focus on what we call <strong>Sushi</strong>, the DAW that is at the core of audio and midi processing in the Elk MusicOS. I hope you find it interesting!</p>
<div class="section" id="main-features">
<h2>Main Features<a class="headerlink" href="#main-features" title="Permalink to this headline">¶</a></h2>
<p>Sushi is a track-based, headless Digital Audio Workstation. It works as a plugin host, supporting multiple plugin standards, features advanced audio and midi routing, simple scripting setup and is written to ensure high performance and stability under low latency conditions. It can be controlled through MIDI, OSC, or a gRPC interface.</p>
<p><strong>In a nutshell:</strong></p>
<ul class="simple">
<li>Headless host with full control over MIDI, OSC and gRPC interfaces.</li>
<li>Hosts VST 2.4, VST 3.6 and Rack Extensions plugins.</li>
<li>Highly optimised for low latency performance.</li>
<li>Multithreaded audio processing support.</li>
<li>Ableton Link support</li>
<li>Audio connections through Raspa, Jack, and file I/O</li>
<li>Simple scripting configuration.</li>
</ul>
</div>
<div class="section" id="architecture">
<h2>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">¶</a></h2>
<p>Sushi shares the same basic architecture with most common DAWs like Cubase or Ableton Live, having an unlimited number of parallel channels. Each track supporting mono, stereo or up to 64 audio channels and as many plugins as the CPU can handle. Pure MIDI tracks are also supported, for instance outputting MIDI from an arpeggiator or step sequencer to an external device.</p>
<p>There is also a multibus track mode with which a multichannel track can have multiple stereo outputs, <strong>each with their own individual gain and panning controls</strong>, which in turn can be routed to any audio output. Useful for multi bus plugins. Sushi also features aux sends and corresponding return tracks for effects processing.</p>
</div>
<div class="section" id="control">
<h2>Control<a class="headerlink" href="#control" title="Permalink to this headline">¶</a></h2>
<p>Sushi supports a number of protocols and technologies for controlling and synching with external sources and devices: MIDI, OSC, Ableton Link, gRPC.</p>
<p>MIDI input and output is supported through <a class="reference external" href="https://www.alsa-project.org/">ALSA</a>. This enables integration with any class compliant midi device, like USB MIDI keyboards or controllers. <strong>A flexible routing system allows you to route MIDI based on channels to any track</strong>. MIDI can be freely routed to tracks and MIDI Program Change and Control Change messages can be mapped to plugins and parameters respectively. MIDI data can also be processed or generated by plugins like sequencers.</p>
<p>Sushi also supports <a class="reference external" href="http://opensoundcontrol.org/introduction-osc">Open Sound Control (OSC)</a>. And can both send OSC updates and receive notes and parameter changes through OSC.</p>
<p>Another cool feature is <strong>tempo sync over Ableton Link</strong>, which enables you to seamlessly tempo sync Sushi with other devices over wifi. This works with computers running <a class="reference external" href="https://www.ableton.com/">Ableton Live</a> or any Link enabled mobile app like <a class="reference external" href="https://itunes.apple.com/se/app/reason-compact-make-music/id1253419004">Reason Compact</a> or <a class="reference external" href="https://www.korg.com/uk/products/software/korg_gadget/">Korg Gadget</a>.</p>
<p>As Sushi is a headless host, and intended for use in an embedded device, it does not feature a graphical user interface. <strong>In its place is a gRPC interface that can be used for controlling all aspects of Sushi and hosted plugins</strong>. gRPC has bindings for most common programming languages, this gives total freedom to customise the behaviour and write a complete GUI for Sushi in more or less any GUI framework of choice and account for multiple use cases.</p>
<p>For some applications, like the upcoming <a class="reference external" href="http://www.dvmark.it/news-detail/namm-2019-new-products/">Smart Multiamp</a> from <a class="reference external" href="http://www.dvmark.it/">DV Mark</a>, user interactions will come from both front panel knobs and a handheld device, i.e. a smartphone or tablet. In that case, an app can use the gRPC interface to control Sushi. Other Elk devices could feature a built-in screen. In that case the GUI will run on the same CPU as Sushi, though in a different process. But as mentioned before, the GUI can be built in Python or any other programming language of choice. <strong>The dual kernel architecture of Elk will guarantee that the graphics rendering will never interfere with the audio dsp processing.</strong></p>
</div>
<div class="section" id="audio-frontends">
<h2>Audio Frontends<a class="headerlink" href="#audio-frontends" title="Permalink to this headline">¶</a></h2>
<p>Sushi supports multiple audio frontends:</p>
<ul class="simple">
<li><strong>RASPA</strong>: Sushi was built to work in perfect sync with Raspa, our proprietary low-latency audio framework.</li>
<li><strong><a class="reference external" href="http://jackaudio.org/">JACK Audio Toolkit</a></strong>: for running real-time code on normal Linux machines.</li>
<li><strong>Offline</strong>: for processing audio and scripted event files (e.g. for automatic testing).</li>
<li><strong>Dummy</strong>: without any connection to audio I/O, useful to debug some real-time safety issues on normal Linux machines.</li>
</ul>
<p><strong>The ability to run Sushi with Jack, the most common audio framework on Linux, makes it possible to run on almost any Linux system</strong>. While it doesn’t give the same ultra low latency as running it with Raspa on an Elk system. It does make it incredibly easy to test and develop plugins and setups for Elk on a standard Linux machine. In fact, <strong>almost all of the development of Sushi has been done on standard Linux machines</strong>.</p>
<p>When running with RASPA, Sushi is limited to the number of inputs and outputs supported by the physical hardware. While when running with Jack, Sushi exposes 8 input ports and 8 output ports that can then be freely routed to physical outputs or inputs, or other Jack software.</p>
<p>The Offline frontend can be used for testing in an environment that lacks audio codecs and for evaluating systems in a very early stage. It has also proven to be very useful in debugging.</p>
<p>See Sushi’s integrated usage help (by running <code class="docutils literal notranslate"><span class="pre">sushi</span> <span class="pre">-h</span></code> or <code class="docutils literal notranslate"><span class="pre">sushi</span> <span class="pre">--help</span></code>), for command line options to choose one of the frontends.</p>
</div>
<div class="section" id="configuration-and-routing">
<h2>Configuration and Routing<a class="headerlink" href="#configuration-and-routing" title="Permalink to this headline">¶</a></h2>
<p>Most of the initial setup of Sushi is done through a <a class="reference external" href="https://en.wikipedia.org/wiki/JSON">JSON</a> configuration file. In this it’s possible to specify the number of tracks to use, their channel setup (mono, stereo, multichannel), the plugins on the track, audio input and output routing, MIDI routing, which plugin parameters map to Control Change messages, and so on. See below for a very simple example for how to set up a synth plugin with MIDI-mapped parameters.</p>
<p><img alt="img" src="../_images/sushi_architecture.png" /></p>
<p>At run-time, Sushi can be controlled via an API available over the network. At the moment, an API based on <a class="reference external" href="http://opensoundcontrol.org/">Open Sound Control</a> (OSC) is available, as well as a more complex API using Google’s gRPC, which offers full control and bidirectional communication to a remote client.</p>
<p>With the run-time RPC API it is possible to perform common tasks such as control of plugins’ automation parameters, track and mixing controls, adding/removing plugin to tracks, querying the engine for track level meters or CPU usage by plugin, etc.</p>
<p>The name, label, id and OSC paths for the hosted plugins’ parameters, is dumped to stdout in JSON format when running Sushi with the flag <code class="docutils literal notranslate"><span class="pre">--dump-plugins</span></code>. This flag starts sushi with the dummy frontend and exits immediately after dumping the parameters.</p>
<p>Sushi’s JSON format is fully specified in a JSON schema, but it is probably easier to learn by studying the provided examples, which cover most common configurations, including multitrack/multichannel configurations.</p>
<p>See our documentation on the <a class="reference internal" href="sushi_configuration_format.html"><span class="doc">Sushi Configuration Format</span></a> for more details.</p>
</div>
<div class="section" id="plugin-format-support">
<h2>Plugin Format Support<a class="headerlink" href="#plugin-format-support" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Sushi can host plugins in Steinberg’s <strong>VST 2.4</strong> and <strong><a class="reference external" href="https://www.steinberg.net/en/company/technologies/vst3.html">VST 3.6</a></strong> formats,  <strong>LV2</strong> (using the LV2VST wrapper), plus an Internal plugin format, which all are abstracted in a generic “Processor” interface.</li>
<li><strong>Reason Studio’s <a class="reference external" href="https://www.propellerheads.com/developers">Rack Extensions</a></strong> are also supported, but due to Reason Studio’s licensing restrictions this support is only available under closed-source commercial licenses of Sushi. Please get in touch for more information.</li>
</ul>
<p>In order to load plugins in Sushi, they need to be compiled for the system intended. Note that it is not possible to take an existing Windows, macOS, or even native Linux plugin binary and load it in Elk. That will not work. Though if the plugins are well written from the start, porting them to Elk should be a rather straightforward process of recompiling the plugins using our SDK.</p>
</div>
<div class="section" id="threading">
<h2>Threading<a class="headerlink" href="#threading" title="Permalink to this headline">¶</a></h2>
<p>Sushi can run its audio processing single threaded but also has <strong>built in multithreading support</strong> to spread the audio processing over multiple cores, depending on the type of system it is running on. For developers that wish to utilise multithreading within a plugin, we have developed a small threading utility library that works with Elk and Sushi, called Twine. This library also includes a few utility functions and wrappers for certain system calls like timers to abstract away some of the limitations of the dual kernel setup.</p>
</div>
<div class="section" id="twine">
<h2>Twine<a class="headerlink" href="#twine" title="Permalink to this headline">¶</a></h2>
<p>Twine is a C++ library that exposes some features of the underlying Xenomai system to plugin developers, particularly accurate and real-time safe timers, and multithreaded worker pools.</p>
<p>The library has a fallback implementation for POSIX systems (tested on standard Linux distros and macOS), which makes it convenient for inclusion in an existing codebase.</p>
<p>Full source code is included in <code class="docutils literal notranslate"><span class="pre">work/twine</span></code> with Doxygen documentation, unit tests and example code.</p>
</div>
<div class="section" id="logging">
<h2>Logging<a class="headerlink" href="#logging" title="Permalink to this headline">¶</a></h2>
<p>On start, Sushi creates a log file in <code class="docutils literal notranslate"><span class="pre">/tmp/sushi.log</span></code> where it logs all relevant run-time information. Logging
level and log destination can be specified with the command line flag <code class="docutils literal notranslate"><span class="pre">-l</span></code> or <code class="docutils literal notranslate"><span class="pre">--log-level</span></code> and <code class="docutils literal notranslate"><span class="pre">-l</span></code> or <code class="docutils literal notranslate"><span class="pre">-L</span></code> <code class="docutils literal notranslate"><span class="pre">-log-file=filename</span></code> respectively.</p>
</div>
<div class="section" id="running-sushi-with-a-different-buffer-size">
<h2>Running Sushi with a Different Buffer Size<a class="headerlink" href="#running-sushi-with-a-different-buffer-size" title="Permalink to this headline">¶</a></h2>
<p>Audio buffer-size is a compile-time option in Sushi, since on embedded systems there’s rarely the need from the user to adjust the buffer size and in this way, the compiler has more room for optimisations.</p>
<p>However, Elk distributions are shipped with Sushi compiled at different buffer sizes, usually [16, 32, 64, 128]. The main command <code class="docutils literal notranslate"><span class="pre">sushi</span></code> is a wrapper around them that, when passed the option <code class="docutils literal notranslate"><span class="pre">-b</span> <span class="pre">N</span></code> as the first argument, select which one to run [default=64].</p>
<p>In case you want to use a different buffer size, you will also need to change the audio driver parameter <code class="docutils literal notranslate"><span class="pre">audio_buffer_size</span></code> in the script placed by default in <code class="docutils literal notranslate"><span class="pre">/usr/bin/load-drivers</span></code> and reboot the board (or restart the audio driver by removing and reinserting the module <code class="docutils literal notranslate"><span class="pre">audio_rtdm</span></code>).</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Sushi: The DAW Inside Elk</a><ul>
<li><a class="reference internal" href="#main-features">Main Features</a></li>
<li><a class="reference internal" href="#architecture">Architecture</a></li>
<li><a class="reference internal" href="#control">Control</a></li>
<li><a class="reference internal" href="#audio-frontends">Audio Frontends</a></li>
<li><a class="reference internal" href="#configuration-and-routing">Configuration and Routing</a></li>
<li><a class="reference internal" href="#plugin-format-support">Plugin Format Support</a></li>
<li><a class="reference internal" href="#threading">Threading</a></li>
<li><a class="reference internal" href="#twine">Twine</a></li>
<li><a class="reference internal" href="#logging">Logging</a></li>
<li><a class="reference internal" href="#running-sushi-with-a-different-buffer-size">Running Sushi with a Different Buffer Size</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="run_elk_on_boards.html"
                        title="previous chapter">Run Elk on Boards</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="sushi_configuration_format.html"
                        title="next chapter">Sushi Configuration</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/documents/sushi_overview.md.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="sushi_configuration_format.html" title="Sushi Configuration"
             >next</a> |</li>
        <li class="right" >
          <a href="run_elk_on_boards.html" title="Run Elk on Boards"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Elk DevKit  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Elk.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>